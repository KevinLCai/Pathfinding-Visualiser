{"version":3,"sources":["PathfindingVisualiser/Node/Node.jsx","algorithms/Dijkstra.js","algorithms/AStar.js","algorithms/BreadthFirstSearch.js","algorithms/DepthFirstSearch.js","PathfindingVisualiser/PathfindingVisualiser.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","row","col","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","isWeight","isVisited","addedClassName","isVisitedWeight","id","className","Component","solveDijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbours","sort","nodeA","nodeB","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","previousNode","destinationRow","destinationCol","nodesInShortestPathOrder","astar","getEuclidianDistance","x1","y1","x2","y2","v1","Math","pow","v2","solveBFS","tempNode","queue","bfs","pathFound","solveDFS","t","dfs","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","isAnimating","holdingFinish","holdingStart","placingWeights","PathfindingVisualiser","addWeights","pop","state","mouseIsPressed","getInitialGrid","setState","localStorage","getItem","overlayOn","setItem","newGrid","augmentGrid","i","setTimeout","animateShortestPath","document","getElementById","algorithm","currentNode","unshift","getNodesInShortestPathOrderDijkstra","solveAStar","getNodesInShortestPathOrderAStar","getNodesInShortestPathOrderBFS","reverse","animateAlgorithm","class","onClick","visualise","title","window","location","reload","src","alt","style","display","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","console","log","j","k","l","App","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9b495085.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row,\n      col,\n      isStart,\n      isFinish,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      isWeight,\n      isVisited,\n      isVisitedWeight,\n    } = this.props;\n    const addedClassName =\n      (isVisited && isWeight) ? 'node-visited node-weight'\n        : isFinish ? 'node-finish'\n          : isStart ? 'node-start'\n            : isWall ? 'node-wall'\n              : isWeight ? 'node-weight'\n                : isVisited ? 'node-visited'\n                  : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${addedClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function solveDijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    if (closestNode.isWeight) {\n      closestNode.distance = closestNode.distance + 6;\n    }\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n  for (const neighbour of unvisitedNeighbours) {\n    neighbour.distance = node.distance + 1;\n    neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const { col, row } = node;\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrderDijkstra(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar destinationRow, destinationCol;\nvar unvisitedNodes = [];\n\nexport function astar(grid, startNode, finishNode) {\n    unvisitedNodes = getAllNodes(grid);\n    startNode.distance = 0;\n    //while there are still unvisited nodes:\n    while (unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        closestNode.isVisited = true;\n        //If we encounter a wall - skip it\n        if (closestNode.isWall) continue;\n        //Increase the distance of a node if it is a weight\n        if (closestNode.isWeight) {\n            closestNode.distance = 150;\n        }\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n        // NEED TO CHANGE\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbours(closestNode, grid);\n    }\n    return visitedNodesInOrder;\n}\n\n//Our heuristic is implemented by measuring distance of current node from the end node\nfunction getEuclidianDistance(x1, y1, x2, y2,) {\n    var v1 = Math.pow(x1 - x2, 2);\n    v1 = v1 ** 2;\n    var v2 = Math.pow(y1 - y2, 2);\n    v2 = v2 ** 2;\n    return Math.pow(v1 + v2, 0.5);\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => {\n        return (nodeA.distance + getEuclidianDistance(nodeA.row, nodeA.col, destinationRow, destinationCol) -\n            (nodeB.distance + getEuclidianDistance(nodeB.row, nodeB.col, destinationRow, destinationCol))\n        );\n    });\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n    for (const neighbour of unvisitedNeighbours) {\n        if (neighbour.isWeight) {\n            neighbour.distance = node.distance + 10;\n            neighbour.previousNode = node;\n        }\n        else {\n            neighbour.distance = node.distance + 1;\n            neighbour.previousNode = node;\n        }\n    }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n    const neighbours = [];\n    const { col, row } = node;\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nexport function getNodesInShortestPathOrderAStar(finishNode) {\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport function solveAStar(grid, startNode, finishNode) {\n    visitedNodesInOrder = [];\n    nodesInShortestPathOrder = [];\n    destinationRow = finishNode.row;\n    destinationCol = finishNode.col;\n    return astar(grid, startNode, finishNode);\n}","var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar destinationRow, destinationCol;\n\nfunction bfs(grid, row, col) {\n    const tempNode = grid[row][col];\n    tempNode.isVisited = true;\n    tempNode.previousNode = null;\n    tempNode.distance = 0;\n    // Implement a Queue\n    var queue = [];\n    queue.push(tempNode);\n    // While the queue is not empty\n    while (queue.length > 0) {\n        var node = queue.shift();\n        visitedNodesInOrder.push(node);\n        //If we have found the end node, return\n        if (node.row == destinationRow && node.col == destinationCol) return;\n        var unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n        for (const neighbour of unvisitedNeighbours) {\n            if (neighbour.isWall) continue;\n            if (neighbour.isVisited === false) {\n                queue.push(neighbour);\n                neighbour.previousNode = node;\n                neighbour.isVisited = true;\n                neighbour.distance = node.distance + 1;\n            }\n        }\n    }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n    const neighbours = [];\n    const { row, col } = node;\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nexport function solveBFS(grid, startNode, finishNode) {\n    visitedNodesInOrder = [];\n    nodesInShortestPathOrder = [];\n    destinationRow = finishNode.row;\n    destinationCol = finishNode.col;\n    bfs(grid, startNode.row, startNode.col);\n    return visitedNodesInOrder;\n}\n\nexport function getNodesInShortestPathOrderBFS(finishNode) {\n    let currentNode = finishNode;\n    while (currentNode) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}","var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar destinationRow, destinationCol;\nvar pathFound = false;\n\nfunction dfs(grid, row, col, distance) {\n    const node = grid[row][col];\n    if (node.isWall) return;\n    visitedNodesInOrder.push(node);\n    node.isVisited = true;\n    node.distance = distance;\n    if (row === destinationRow && col === destinationCol) {\n        nodesInShortestPathOrder.push(node);\n        pathFound = true;\n        return;\n    }\n\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n    for (const neighbour of unvisitedNeighbours) {\n        if (neighbour.isVisited === false) {\n            dfs(grid, neighbour.row, neighbour.col, node, distance + 1);\n            if (pathFound) {\n                nodesInShortestPathOrder.push(node);\n                break;\n            }\n        }\n    }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n    const neighbours = [];\n    const { row, col } = node;\n    if (row > 0) neighbours.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col > 0) neighbours.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nexport function solveDFS(grid, startNode, finishNode, t) {\n    visitedNodesInOrder = [];\n    nodesInShortestPathOrder = [];\n    pathFound = false;\n    destinationRow = finishNode.row;\n    destinationCol = finishNode.col;\n    dfs(grid, startNode.row, startNode.col, 0);\n    return visitedNodesInOrder;\n}\n\nexport function getNodesInShortestPathOrderDFS() {\n    nodesInShortestPathOrder.reverse();\n    return nodesInShortestPathOrder;\n}","import React, { Component } from 'react';\nimport './PathfindingVisualiser.css';\n\n\nimport Node from './Node/Node';\n\nimport { solveDijkstra, getNodesInShortestPathOrderDijkstra } from '../algorithms/Dijkstra';\nimport { solveAStar, getNodesInShortestPathOrderAStar } from \"../algorithms/AStar\";\nimport { solveBFS, getNodesInShortestPathOrderBFS } from \"../algorithms/BreadthFirstSearch\";\nimport { solveDFS, getNodesInShortestPathOrderDFS } from \"../algorithms/DepthFirstSearch\";\n\nvar START_NODE_ROW = 10;\nvar START_NODE_COL = 15;\nvar FINISH_NODE_ROW = 10;\nvar FINISH_NODE_COL = 35;\nvar isAnimating = false;\nvar holdingFinish = false;\nvar holdingStart = false;\nvar placingWeights = [];\nvar visitedNodesInOrder, nodesInShortestPathOrder;\n\n// Initialise this into PathfindingVisualiser component\nexport default class PathfindingVisualiser extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n  // Initialise DOM content with grid\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n\n    if (!localStorage.getItem(\"visted\")) {\n      overlayOn();\n      localStorage.setItem(\"visted\", true);\n    }\n  }\n\n  handleMouseDown(row, col) {\n    if (!isAnimating) {\n      const newGrid = augmentGrid(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n  // When the mouse is pressed, we want to update the grid\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    var newGrid = augmentGrid(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n  // When mouse is lifted, set mouseIsPressed to false\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n    holdingFinish = false;\n    holdingStart = false;\n  }\n\n  // Takes in which nodes have been visited and shortest path, for each node, set the node to visited\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (!node.isWeight) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }\n        else {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited node-weight';\n        }\n      }, 10 * i);\n    }\n  }\n\n  visualise(algorithm) {\n    //Prevents user from changing the map after animating an algorithm.\n    if (!isAnimating) {\n      isAnimating = true;\n      const { grid } = this.state;\n      //- CHOSE NOT TO IMPLEMENT THIS FUNCTIONALITY AT THE MOMENT\n      // clearBoard(grid);\n      var startNode = grid[START_NODE_ROW][START_NODE_COL];\n      var finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      //Identify which algorithm to run:\n      if (algorithm === 'Dijkstra') {\n        visitedNodesInOrder = solveDijkstra(grid, startNode, finishNode);\n        nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode);\n      } else if (algorithm === 'AStar') {\n        visitedNodesInOrder = solveAStar(grid, startNode, finishNode);\n        nodesInShortestPathOrder = getNodesInShortestPathOrderAStar(finishNode);\n      } else if (algorithm === 'BFS') {\n        visitedNodesInOrder = solveBFS(grid, startNode, finishNode);\n        nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode);\n      } else if (algorithm === 'DFS') {\n        visitedNodesInOrder = solveDFS(grid, startNode, finishNode);\n        nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode);\n      }\n      this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n\n        if (document.getElementById(`node-${node.row}-${node.col}`).className === 'node node-visited') {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-shortest-path'\n        }\n      }, 20 * i);\n    }\n  }\n\n  // Allow functionality for adding weights to the map\n  addWeights = (placingWeights) => {\n    if (placingWeights.pop()) {\n      placingWeights.push(false);\n    } else {\n      placingWeights.push(true);\n    }\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n    // HTML to render:\n    return (\n      <div>\n        {/* buttons  to trigger visualise function */}\n        <div class=\"full-panel\">\n          <div class=\"panel\">\n            <button onClick={() => this.visualise('Dijkstra')} class=\"btn btn-primary\"\n              title=\"Dijkstra's algorithm is a weighted search algorithm which guarantees the shortest path between two nodes. Press the 'Deforest' button to \n              remove parts of the forest (essentially adding weights to the search algorithm). Dijkstra's algorithm is a good visual representation of \n              a forest-fire especially since deforested nodes (weights) can slow down the spread of fire.\">\n              Dijkstra's Algorithm\n            </button>\n          </div>\n          <div class=\"panel\">\n            <button onClick={() => this.visualise('AStar')} class=\"btn btn-warning\" title=\"A* Search is a weighted search algorithm which guarantees the shortest path between two nodes. A* is a version of Dijkstra's \n            algorithm, but with a heuristic that moves in the direction of the finish node. Press the 'Deforest' button to \n              remove parts of the forest (essentially adding weights to the search algorithm).\">\n              A* Search\n            </button>\n          </div>\n          <div class=\"panel\">\n            <button onClick={() => this.visualise('BFS')} class=\"btn btn-danger\" title=\"Breadth-first-search is an unweighted search algorithm, it will therefore ignore\n            any deforested nodes placed on the map. It guarantees the shortest path between two points and is a good model for the spread of fire.\">\n              Breadth-first search\n            </button>\n          </div>\n          <div class=\"panel\">\n            <button onClick={() => this.visualise('DFS')} class=\"btn btn-info\" title=\"Depth-first-search is an unweighted search algorithm, it will therefore ignore\n            any deforested nodes placed on the map. It does not guarantee the shortest path between two points and is not analagous to the spread of fire.\">\n              Depth-first search\n            </button>\n          </div>\n          <div class=\"panel\">\n            <button onClick={() => this.addWeights(placingWeights)} class=\"btn btn-success\" title=\"The deforest button can be toggled on and off. When toggle on it allows you to place\n            weighted nodes which are analgous to deforesting the map. When toggled off, it allows you to place wall nodes. Have a go!\">\n              Deforest\n            </button>\n          </div>\n          <div class=\"panel\">\n            <button onClick={() => { window.location.reload() }} class=\"btn btn-light\" title=\"Resets the board entirely.\">\n              Reset Board\n            </button>\n          </div>\n          <div class=\"panel\">\n            <button onClick={() => overlayOn()} class=\"btn btn-default\" title=\"Open the information window.\">\n              Info\n            </button>\n          </div>\n        </div>\n\n        {/* OVERLAY */}\n        <div id=\"overlay\">\n          <div id=\"navigator\">\n            <div>\n              <h1>Hello! Welcome to Kevin Cai's Forest Fire Simulator!</h1>\n              <p>\n                This simulator uses different Pathfinding Algorithms including: Dijkstra's algorithm, A* Search, Breadth-first-search and Depth-first-search. Each with varying levels of\n                accuracy at simulating forest fires. I shall walk you through the functionality of this web application.\n            </p>\n            </div>\n            <div>\n              <h1>What is a Pathfinding Algorithm?</h1>\n              <p>\n                A pathfinding algorithm seeks to find the shortest path between two points, this application aims to visualise different algorithms and apply them\n                towards simulating the spread of fire within a forest. These algorithms have been applied to a 2 dimensional grid.\n              </p>\n            </div>\n            <div>\n              <h1>Different Nodes:</h1>\n              <div>\n                <img src=\"https://i.pinimg.com/originals/af/ab/26/afab26f2c1d6ef0cd3402dd5ef77e2de.jpg\" alt=\"Flame\"></img>\n                <p class=\"p-node\">This is the <strong>Start Node</strong>, where the fire will start. Click and drag it to move its position.</p>\n              </div>\n              <div>\n                <img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Checkerboard_pattern.svg/1024px-Checkerboard_pattern.svg.png\" alt=\"Checkerboard\"></img>\n                <p class=\"p-node\">This is the <strong>Finish Node</strong>, where the simulation will end. Click and drag it to move its position.</p>\n              </div>\n              <div>\n                <img src=\"https://www.htmlcsscolor.com/preview/gallery/008000.png\" alt=\"Green Square\"></img>\n                <p class=\"p-node\">This is a <strong>Tree Node</strong>, these nodes can be burned down and allow the spread of fire.</p>\n              </div>\n              <div>\n                <img src=\"https://lh3.googleusercontent.com/PGDDIlrdxLg8-6jGX-O_fw2xcV6fO1PcRcm1cbxMrmtrUODDtkZC9Hl05G2KAAkbcub39SUinulK6NKZmnN9=s400\" alt=\"Clay Brick Square\"></img>\n                <p class=\"p-node\">This is a <strong>Wall Node</strong>, fire cannot pass through this node. Click and drag on the map to create walls!</p>\n              </div>\n              <div>\n                <img src=\"https://www.jordanreflectors.co.uk/wp-content/uploads/2016/05/Opallite-Recessed-LED-Luminaires-black-border-670px.jpg\" alt=\"White Square\"></img>\n                <p class=\"p-node\">This is a <strong>Deforested/Weighted Node</strong>, this increases the difficulty for the fire to spread (affects weighted algorithms - Dijkstra's algorithm and A* Search). Click the \"Deforest\" button to toggle on deforestation - then click and drag on the map to deforest.</p>\n              </div>\n              <div>\n                <img src=\"https://i.pinimg.com/originals/b6/e1/44/b6e14486d7b5930471fabad8aa2cab19.jpg\" alt=\"Yellow Brick Square\"></img>\n                <p class=\"p-node\">This is a <strong>Shortest-path Node</strong>, which maps out the shortest path between the Start Node and the Finish Node. Follow the yellow brick road! (Note: for Depth-first-search, this path is certainly not the shortest path!)</p>\n              </div>\n            </div>\n            <div>\n              <h1>Search algorithms:</h1>\n              <ul>\n                <li><strong>Dijkstra's Algorithm:</strong> a weighted search algorithm which guarantees the shortest path between two nodes. Dijkstra's algorithm is a good visual representation of\n              a forest-fire especially since deforested nodes (weights) can slow down the spread of fire.</li>\n                <li><strong>A* Search:</strong> a weighted search algorithm which guarantees the shortest path between two nodes. A* is a version of Dijkstra's\n                algorithm, but with a heuristic that moves in the direction of the finish node. A* Search is a poor visual representation of\n                the spread of fire, however, has other fascinating use cases - it is the algorithm Google use for Google Maps! </li>\n                <li><strong>Breadth-first-search:</strong> an unweighted search algorithm, it will therefore ignore\n            any deforested nodes placed on the map. It does not guarantee the shortest path between two points and follows a similar path as the spread of fire, however, it ignores any deforestation. A common application of this search algorithm is in Peer to Peer networks to\n            find neighbouring nodes.</li>\n                <li><strong>Depth-first-search:</strong> an unweighted search algorithm, it will therefore ignore\n            any deforested nodes placed on the map. It does not guarantee the shortest path between two points and is not analagous to the spread of fire.\n            Depth first search can be used to solve puzzles with only one solution, e.g. solve a maze.</li>\n              </ul>\n            </div>\n          </div>\n          <button onClick={() => overlayOff()} class=\"btn btn-default\" id=\"overlay-button\">\n            Hide Window\n            </button>\n        </div>\n\n        {/* Display grid of nodes */}\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall, isWeight, isVisited, isVisitedWeight, } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      row={row}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      isWeight={isWeight}\n                      isVisited={isVisited}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                      onMouseUp={() => this.handleMouseUp()}>\n                    </Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\n// creates an initial 20 x 50 grid using a nested for loop\nconst getInitialGrid = () => {\n  let grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n// creates a node, using column and row positions\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    isWeight: false,\n  };\n};\n\n// newGrid is a copy of grid, changes the node and updates grid\nconst augmentGrid = (grid, row, col) => {\n  //copy grid\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  var newNode = newGrid[row][col];\n  if (!node.isFinish && !node.isStart && !holdingFinish && !placingWeights[0] && !holdingStart && !holdingFinish) {\n    newNode = {\n      ...node,\n      isWall: !node.isWall,\n    }\n  }\n  //  detect weights\n  else if (placingWeights[0]) {\n    console.log(\"WEIGHTS\")\n    newNode = {\n      ...node,\n      isWeight: true,\n    }\n  }\n  //MOVE FINISH NODE\n  else if (newGrid[row][col].row === FINISH_NODE_ROW && newGrid[row][col].col === FINISH_NODE_COL) {\n    holdingFinish = true;\n  }\n  else if (holdingFinish) {\n    newNode = {\n      ...node,\n      isFinish: true,\n    }\n    FINISH_NODE_ROW = newGrid[row][col].row;\n    FINISH_NODE_COL = newGrid[row][col].col;\n\n    // look through all the nodes, if a non-finish node is still displayed as finish - switch the boolean\n    for (var i = 0; i < 20; i++) {\n      for (var j = 0; j < 50; j++) {\n        if (newGrid[i][j].isFinish) {\n          document.getElementById(`node-${i}-${j}`).className = \"node\";\n        }\n      }\n    }\n  }\n  //MOVE START NODE - same logic as finish node\n  else if (newGrid[row][col].isStart) {\n    holdingStart = true;\n  }\n  else if (holdingStart) {\n    newNode = {\n      ...node,\n      isStart: true,\n    }\n    START_NODE_ROW = newGrid[row][col].row;\n    START_NODE_COL = newGrid[row][col].col;\n\n    for (var k = 0; k < 20; k++) {\n      for (var l = 0; l < 50; l++) {\n        if (newGrid[k][l].isStart) {\n          document.getElementById(`node-${k}-${l}`).className = \"node\";\n          newGrid[k][l].isStart = false;\n        }\n      }\n    }\n  }\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nfunction overlayOn() {\n  document.getElementById(\"overlay\").style.display = \"block\";\n}\n\nfunction overlayOff() {\n  document.getElementById(\"overlay\").style.display = \"none\";\n}\n\n//Below are functions that may be implemented in the future!\n\n// //CLEAR BOARD WHEN NEW ALGO CALLED\n// function clearBoard(grid) {\n//   for (var k = 0; k < 20; k++) {\n//     for (var l = 0; l < 50; l++) {\n//       // reset all nodes that arent finish node, start node, wall or weights back to a normal node\n//       // !(((grid[k][l].row === FINISH_NODE_ROW)) && ((grid[k][l].col === FINISH_NODE_COL))) && !grid[k][l].isWall && !grid[k][l].isWeight\n\n//       // FOR ALL NODES\n//       // if node is visited and isn't start or finish node\n//       if (((document.getElementById(`node-${k}-${l}`).className === \"node node-visited\") && (!(((grid[k][l].row === FINISH_NODE_ROW)) && ((grid[k][l].col === FINISH_NODE_COL))))) || (document.getElementById(`node-${k}-${l}`).className === \"node node-shortest-path\")) {\n//         document.getElementById(`node-${k}-${l}`).className = \"node\";\n//       }\n//       if ((grid[k][l].row === FINISH_NODE_ROW) && (grid[k][l].col === FINISH_NODE_COL)) {\n//         document.getElementById(`node-${k}-${l}`).className = \"node node-finish\";\n//       }\n//       if ((grid[k][l].row === START_NODE_ROW) && (grid[k][l].col === START_NODE_COL)) {\n//         document.getElementById(`node-${k}-${l}`).className = \"node node-start\";\n//       }\n//       if ((grid[k][l].isWeight)) {\n//         document.getElementById(`node-${k}-${l}`).className = \"node node-weight\";\n//       }\n//     }\n//   }\n// }\n\n// function refreshTextures(grid) {\n//   for (var k = 0; k < 20; k++) {\n//     for (var l = 0; l < 50; l++) {\n//       if ((grid[k][l].row === FINISH_NODE_ROW) && (grid[k][l].col === FINISH_NODE_COL)) {\n//         document.getElementById(`node-${k}-${l}`).className = \"node node-finish\";\n//       }\n//       if ((grid[k][l].row === START_NODE_ROW) && (grid[k][l].col === START_NODE_COL)) {\n//         document.getElementById(`node-${k}-${l}`).className = \"node node-start\";\n//       }\n//       if ((grid[k][l].isWeight)) {\n//         document.getElementById(`node-${k}-${l}`).className = \"node node-weight\";\n//       }\n//     }\n//   }\n// }","import React from 'react';\nimport './App.css';\nimport PathfindingVisualiser from './PathfindingVisualiser/PathfindingVisualiser';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualiser></PathfindingVisualiser>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}